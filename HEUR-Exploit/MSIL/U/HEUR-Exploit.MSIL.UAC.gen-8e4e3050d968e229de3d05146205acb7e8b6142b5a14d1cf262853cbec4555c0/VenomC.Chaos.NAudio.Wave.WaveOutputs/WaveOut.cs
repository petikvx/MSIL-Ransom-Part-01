using System;
using System.Runtime.InteropServices;
using System.Threading;
using VenomC.Chaos.NAudio.Wave.WaveStreams;

namespace VenomC.Chaos.NAudio.Wave.WaveOutputs;

public class WaveOut : IDisposable, IWavePlayer, GInterface2
{
	private IntPtr hWaveOut;

	private WaveOutBuffer[] buffers;

	private GInterface3 waveStream;

	private volatile GEnum8 playbackState;

	private Class18.Delegate12 callback;

	private float volume = 1f;

	private GClass17 callbackInfo;

	private object waveOutLock;

	private int queuedBuffers;

	private SynchronizationContext syncContext;

	public static int DeviceCount => Class18.waveOutGetNumDevs();

	public int DesiredLatency { get; set; }

	public int NumberOfBuffers { get; set; }

	public int DeviceNumber { get; set; }

	public GClass15 OutputWaveFormat => waveStream.WaveFormat;

	public GEnum8 PlaybackState => playbackState;

	public float Volume
	{
		get
		{
			return volume;
		}
		set
		{
			SetWaveOutVolume(value, hWaveOut, waveOutLock);
			volume = value;
		}
	}

	public event EventHandler<GEventArgs0> PlaybackStopped;

	public static GStruct2 GetCapabilities(int devNumber)
	{
		GStruct2 waveOutCaps = default(GStruct2);
		int waveOutCapsSize = Marshal.SizeOf(waveOutCaps);
		GException0.smethod_1(Class18.waveOutGetDevCaps((IntPtr)devNumber, out waveOutCaps, waveOutCapsSize), "waveOutGetDevCaps");
		return waveOutCaps;
	}

	public WaveOut()
		: this((SynchronizationContext.Current == null) ? GClass17.smethod_0() : GClass17.smethod_1())
	{
	}

	public WaveOut(IntPtr windowHandle)
		: this(GClass17.smethod_2(windowHandle))
	{
	}

	public WaveOut(GClass17 callbackInfo)
	{
		syncContext = SynchronizationContext.Current;
		DeviceNumber = 0;
		DesiredLatency = 300;
		NumberOfBuffers = 2;
		callback = Callback;
		waveOutLock = new object();
		this.callbackInfo = callbackInfo;
		callbackInfo.method_0(callback);
	}

	public void Init(GInterface3 waveProvider)
	{
		waveStream = waveProvider;
		int bufferSize = waveProvider.WaveFormat.method_0((DesiredLatency + NumberOfBuffers - 1) / NumberOfBuffers);
		GEnum11 result;
		lock (waveOutLock)
		{
			result = callbackInfo.method_1(out hWaveOut, DeviceNumber, waveStream.WaveFormat, callback);
		}
		GException0.smethod_1(result, "waveOutOpen");
		buffers = new WaveOutBuffer[NumberOfBuffers];
		playbackState = GEnum8.const_0;
		for (int i = 0; i < NumberOfBuffers; i++)
		{
			buffers[i] = new WaveOutBuffer(hWaveOut, bufferSize, waveStream, waveOutLock);
		}
	}

	public void Play()
	{
		if (playbackState == GEnum8.const_0)
		{
			playbackState = GEnum8.const_1;
			EnqueueBuffers();
		}
		else if (playbackState == GEnum8.const_2)
		{
			EnqueueBuffers();
			Resume();
			playbackState = GEnum8.const_1;
		}
	}

	private void EnqueueBuffers()
	{
		int num = 0;
		while (true)
		{
			if (num >= NumberOfBuffers)
			{
				return;
			}
			if (!buffers[num].InQueue)
			{
				if (!buffers[num].OnDone())
				{
					break;
				}
				Interlocked.Increment(ref queuedBuffers);
			}
			num++;
		}
		playbackState = GEnum8.const_0;
	}

	public void Pause()
	{
		if (playbackState == GEnum8.const_1)
		{
			playbackState = GEnum8.const_2;
			GEnum11 gEnum;
			lock (waveOutLock)
			{
				gEnum = Class18.waveOutPause(hWaveOut);
			}
			if (gEnum != 0)
			{
				throw new GException0(gEnum, "waveOutPause");
			}
		}
	}

	public void Resume()
	{
		if (playbackState == GEnum8.const_2)
		{
			GEnum11 gEnum;
			lock (waveOutLock)
			{
				gEnum = Class18.waveOutRestart(hWaveOut);
			}
			if (gEnum != 0)
			{
				throw new GException0(gEnum, "waveOutRestart");
			}
			playbackState = GEnum8.const_1;
		}
	}

	public void Stop()
	{
		if (playbackState != 0)
		{
			playbackState = GEnum8.const_0;
			GEnum11 gEnum;
			lock (waveOutLock)
			{
				gEnum = Class18.waveOutReset(hWaveOut);
			}
			if (gEnum != 0)
			{
				throw new GException0(gEnum, "waveOutReset");
			}
			if (callbackInfo.Strategy == GEnum12.const_0)
			{
				RaisePlaybackStoppedEvent(null);
			}
		}
	}

	public long GetPosition()
	{
		lock (waveOutLock)
		{
			Struct4 mmTime = default(Struct4);
			mmTime.uint_0 = 4u;
			GException0.smethod_1(Class18.waveOutGetPosition(hWaveOut, out mmTime, Marshal.SizeOf(mmTime)), "waveOutGetPosition");
			if (mmTime.uint_0 != 4)
			{
				throw new Exception($"waveOutGetPosition: wType -> Expected {4}, Received {mmTime.uint_0}");
			}
			return mmTime.uint_3;
		}
	}

	internal static void SetWaveOutVolume(float value, IntPtr hWaveOut, object lockObject)
	{
		if (value < 0f)
		{
			throw new ArgumentOutOfRangeException("value", "Volume must be between 0.0 and 1.0");
		}
		if (value > 1f)
		{
			throw new ArgumentOutOfRangeException("value", "Volume must be between 0.0 and 1.0");
		}
		int dwVolume = (int)(value * 65535f) + ((int)(value * 65535f) << 16);
		GEnum11 result;
		lock (lockObject)
		{
			result = Class18.waveOutSetVolume(hWaveOut, dwVolume);
		}
		GException0.smethod_1(result, "waveOutSetVolume");
	}

	public void Dispose()
	{
		GC.SuppressFinalize(this);
		Dispose(disposing: true);
	}

	protected void Dispose(bool disposing)
	{
		Stop();
		if (disposing && buffers != null)
		{
			for (int i = 0; i < buffers.Length; i++)
			{
				if (buffers[i] != null)
				{
					buffers[i].Dispose();
				}
			}
			buffers = null;
		}
		lock (waveOutLock)
		{
			Class18.waveOutClose(hWaveOut);
		}
		if (disposing)
		{
			callbackInfo.method_3();
		}
	}

	~WaveOut()
	{
		Dispose(disposing: false);
	}

	private void Callback(IntPtr hWaveOut, Class18.Enum4 uMsg, IntPtr dwInstance, Class16 wavhdr, IntPtr dwReserved)
	{
		if (uMsg != Class18.Enum4.const_4)
		{
			return;
		}
		WaveOutBuffer waveOutBuffer = (WaveOutBuffer)((GCHandle)wavhdr.intptr_1).Target;
		Interlocked.Decrement(ref queuedBuffers);
		Exception e = null;
		if (PlaybackState == GEnum8.const_1)
		{
			lock (waveOutLock)
			{
				try
				{
					if (waveOutBuffer.OnDone())
					{
						Interlocked.Increment(ref queuedBuffers);
					}
				}
				catch (Exception ex)
				{
					e = ex;
				}
			}
		}
		if (queuedBuffers == 0 && (callbackInfo.Strategy != 0 || playbackState != 0))
		{
			playbackState = GEnum8.const_0;
			RaisePlaybackStoppedEvent(e);
		}
	}

	private void RaisePlaybackStoppedEvent(Exception e)
	{
		EventHandler<GEventArgs0> handler = this.PlaybackStopped;
		if (handler == null)
		{
			return;
		}
		if (syncContext == null)
		{
			handler(this, new GEventArgs0(e));
			return;
		}
		syncContext.Post(delegate
		{
			handler(this, new GEventArgs0(e));
		}, null);
	}
}
