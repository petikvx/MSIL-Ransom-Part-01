using System;
using System.Runtime.InteropServices;

namespace VenomC.Chaos.NAudio.Wave.WaveStreams;

internal class WaveInBuffer : IDisposable
{
	private readonly Class16 header;

	private readonly int bufferSize;

	private readonly byte[] buffer;

	private GCHandle hBuffer;

	private IntPtr waveInHandle;

	private GCHandle hHeader;

	private GCHandle hThis;

	public byte[] Data => buffer;

	public bool Done => (header.genum13_0 & GEnum13.flag_1) == GEnum13.flag_1;

	public bool InQueue => (header.genum13_0 & GEnum13.flag_3) == GEnum13.flag_3;

	public int BytesRecorded => header.int_1;

	public int BufferSize => bufferSize;

	public WaveInBuffer(IntPtr waveInHandle, int bufferSize)
	{
		this.bufferSize = bufferSize;
		buffer = new byte[bufferSize];
		hBuffer = GCHandle.Alloc(buffer, GCHandleType.Pinned);
		this.waveInHandle = waveInHandle;
		header = new Class16();
		hHeader = GCHandle.Alloc(header, GCHandleType.Pinned);
		header.intptr_0 = hBuffer.AddrOfPinnedObject();
		header.int_0 = bufferSize;
		header.int_2 = 1;
		hThis = GCHandle.Alloc(this);
		header.intptr_1 = (IntPtr)hThis;
		GException0.smethod_1(Class18.waveInPrepareHeader(waveInHandle, header, Marshal.SizeOf(header)), "waveInPrepareHeader");
	}

	public void Reuse()
	{
		GException0.smethod_1(Class18.waveInUnprepareHeader(waveInHandle, header, Marshal.SizeOf(header)), "waveUnprepareHeader");
		GException0.smethod_1(Class18.waveInPrepareHeader(waveInHandle, header, Marshal.SizeOf(header)), "waveInPrepareHeader");
		GException0.smethod_1(Class18.waveInAddBuffer(waveInHandle, header, Marshal.SizeOf(header)), "waveInAddBuffer");
	}

	~WaveInBuffer()
	{
		Dispose(disposing: false);
	}

	public void Dispose()
	{
		GC.SuppressFinalize(this);
		Dispose(disposing: true);
	}

	protected void Dispose(bool disposing)
	{
		if (waveInHandle != IntPtr.Zero)
		{
			Class18.waveInUnprepareHeader(waveInHandle, header, Marshal.SizeOf(header));
			waveInHandle = IntPtr.Zero;
		}
		if (hHeader.IsAllocated)
		{
			hHeader.Free();
		}
		if (hBuffer.IsAllocated)
		{
			hBuffer.Free();
		}
		if (hThis.IsAllocated)
		{
			hThis.Free();
		}
	}
}
