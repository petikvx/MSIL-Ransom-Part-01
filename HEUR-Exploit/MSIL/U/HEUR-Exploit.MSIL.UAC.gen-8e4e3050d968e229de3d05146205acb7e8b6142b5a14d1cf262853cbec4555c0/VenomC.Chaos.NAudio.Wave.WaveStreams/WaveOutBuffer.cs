using System;
using System.Runtime.InteropServices;

namespace VenomC.Chaos.NAudio.Wave.WaveStreams;

internal class WaveOutBuffer : IDisposable
{
	private readonly Class16 header;

	private readonly int bufferSize;

	private readonly byte[] buffer;

	private readonly GInterface3 waveStream;

	private readonly object waveOutLock;

	private GCHandle hBuffer;

	private IntPtr hWaveOut;

	private GCHandle hHeader;

	private GCHandle hThis;

	public bool InQueue => (header.genum13_0 & GEnum13.flag_3) == GEnum13.flag_3;

	public int BufferSize => bufferSize;

	public WaveOutBuffer(IntPtr hWaveOut, int bufferSize, GInterface3 bufferFillStream, object waveOutLock)
	{
		this.bufferSize = bufferSize;
		buffer = new byte[bufferSize];
		hBuffer = GCHandle.Alloc(buffer, GCHandleType.Pinned);
		this.hWaveOut = hWaveOut;
		waveStream = bufferFillStream;
		this.waveOutLock = waveOutLock;
		header = new Class16();
		hHeader = GCHandle.Alloc(header, GCHandleType.Pinned);
		header.intptr_0 = hBuffer.AddrOfPinnedObject();
		header.int_0 = bufferSize;
		header.int_2 = 1;
		hThis = GCHandle.Alloc(this);
		header.intptr_1 = (IntPtr)hThis;
		lock (waveOutLock)
		{
			GException0.smethod_1(Class18.waveOutPrepareHeader(hWaveOut, header, Marshal.SizeOf(header)), "waveOutPrepareHeader");
		}
	}

	~WaveOutBuffer()
	{
		Dispose(disposing: false);
	}

	public void Dispose()
	{
		GC.SuppressFinalize(this);
		Dispose(disposing: true);
	}

	protected void Dispose(bool disposing)
	{
		if (hHeader.IsAllocated)
		{
			hHeader.Free();
		}
		if (hBuffer.IsAllocated)
		{
			hBuffer.Free();
		}
		if (hThis.IsAllocated)
		{
			hThis.Free();
		}
		if (hWaveOut != IntPtr.Zero)
		{
			lock (waveOutLock)
			{
				Class18.waveOutUnprepareHeader(hWaveOut, header, Marshal.SizeOf(header));
			}
			hWaveOut = IntPtr.Zero;
		}
	}

	internal bool OnDone()
	{
		int num;
		lock (waveStream)
		{
			num = waveStream.Read(buffer, 0, buffer.Length);
		}
		if (num == 0)
		{
			return false;
		}
		for (int i = num; i < buffer.Length; i++)
		{
			buffer[i] = 0;
		}
		WriteToWaveOut();
		return true;
	}

	private void WriteToWaveOut()
	{
		GEnum11 gEnum;
		lock (waveOutLock)
		{
			gEnum = Class18.waveOutWrite(hWaveOut, header, Marshal.SizeOf(header));
		}
		if (gEnum != 0)
		{
			throw new GException0(gEnum, "waveOutWrite");
		}
		GC.KeepAlive(this);
	}
}
