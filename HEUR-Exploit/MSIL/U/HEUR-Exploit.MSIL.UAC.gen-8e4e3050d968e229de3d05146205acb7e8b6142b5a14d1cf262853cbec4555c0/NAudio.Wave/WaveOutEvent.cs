using System;
using System.Runtime.InteropServices;
using System.Threading;
using VenomC.Chaos.NAudio.Wave.WaveOutputs;
using VenomC.Chaos.NAudio.Wave.WaveStreams;

namespace NAudio.Wave;

public class WaveOutEvent : IDisposable, IWavePlayer, GInterface2
{
	private readonly object waveOutLock;

	private readonly SynchronizationContext syncContext;

	private IntPtr hWaveOut;

	private WaveOutBuffer[] buffers;

	private GInterface3 waveStream;

	private volatile GEnum8 playbackState;

	private AutoResetEvent callbackEvent;

	private float volume = 1f;

	public int DesiredLatency { get; set; }

	public int NumberOfBuffers { get; set; }

	public int DeviceNumber { get; set; }

	public GClass15 OutputWaveFormat => waveStream.WaveFormat;

	public GEnum8 PlaybackState => playbackState;

	public float Volume
	{
		get
		{
			return volume;
		}
		set
		{
			WaveOut.SetWaveOutVolume(value, hWaveOut, waveOutLock);
			volume = value;
		}
	}

	public event EventHandler<GEventArgs0> PlaybackStopped;

	public WaveOutEvent()
	{
		syncContext = SynchronizationContext.Current;
		if (syncContext != null && (syncContext.GetType().Name == "LegacyAspNetSynchronizationContext" || syncContext.GetType().Name == "AspNetSynchronizationContext"))
		{
			syncContext = null;
		}
		DeviceNumber = 0;
		DesiredLatency = 300;
		NumberOfBuffers = 2;
		waveOutLock = new object();
	}

	public void Init(GInterface3 waveProvider)
	{
		if (playbackState != 0)
		{
			throw new InvalidOperationException("Can't re-initialize during playback");
		}
		if (hWaveOut != IntPtr.Zero)
		{
			DisposeBuffers();
			CloseWaveOut();
		}
		callbackEvent = new AutoResetEvent(initialState: false);
		waveStream = waveProvider;
		int bufferSize = waveProvider.WaveFormat.method_0((DesiredLatency + NumberOfBuffers - 1) / NumberOfBuffers);
		GEnum11 result;
		lock (waveOutLock)
		{
			result = Class18.waveOutOpen_1(out hWaveOut, (IntPtr)DeviceNumber, waveStream.WaveFormat, callbackEvent.SafeWaitHandle.DangerousGetHandle(), IntPtr.Zero, Class18.Enum3.flag_2);
		}
		GException0.smethod_1(result, "waveOutOpen");
		buffers = new WaveOutBuffer[NumberOfBuffers];
		playbackState = GEnum8.const_0;
		for (int i = 0; i < NumberOfBuffers; i++)
		{
			buffers[i] = new WaveOutBuffer(hWaveOut, bufferSize, waveStream, waveOutLock);
		}
	}

	public void Play()
	{
		if (buffers != null && waveStream != null)
		{
			if (playbackState == GEnum8.const_0)
			{
				playbackState = GEnum8.const_1;
				callbackEvent.Set();
				ThreadPool.QueueUserWorkItem(delegate
				{
					PlaybackThread();
				}, null);
			}
			else if (playbackState == GEnum8.const_2)
			{
				Resume();
				callbackEvent.Set();
			}
			return;
		}
		throw new InvalidOperationException("Must call Init first");
	}

	private void PlaybackThread()
	{
		Exception e = null;
		try
		{
			DoPlayback();
		}
		catch (Exception ex)
		{
			e = ex;
		}
		finally
		{
			playbackState = GEnum8.const_0;
			RaisePlaybackStoppedEvent(e);
		}
	}

	private void DoPlayback()
	{
		//IL_0016: Ignored invalid 'volatile' prefix
		while (playbackState != 0)
		{
			if (callbackEvent.WaitOne(DesiredLatency))
			{
				/*Error: Could not find block for branch target IL_0018*/;
			}
			if (playbackState != GEnum8.const_1)
			{
				continue;
			}
			int num = 0;
			WaveOutBuffer[] array = buffers;
			foreach (WaveOutBuffer waveOutBuffer in array)
			{
				if (waveOutBuffer.InQueue || waveOutBuffer.OnDone())
				{
					num++;
				}
			}
			if (num == 0)
			{
				playbackState = GEnum8.const_0;
				callbackEvent.Set();
			}
		}
	}

	public void Pause()
	{
		if (playbackState == GEnum8.const_1)
		{
			playbackState = GEnum8.const_2;
			GEnum11 gEnum;
			lock (waveOutLock)
			{
				gEnum = Class18.waveOutPause(hWaveOut);
			}
			if (gEnum != 0)
			{
				throw new GException0(gEnum, "waveOutPause");
			}
		}
	}

	private void Resume()
	{
		if (playbackState == GEnum8.const_2)
		{
			GEnum11 gEnum;
			lock (waveOutLock)
			{
				gEnum = Class18.waveOutRestart(hWaveOut);
			}
			if (gEnum != 0)
			{
				throw new GException0(gEnum, "waveOutRestart");
			}
			playbackState = GEnum8.const_1;
		}
	}

	public void Stop()
	{
		if (playbackState != 0)
		{
			playbackState = GEnum8.const_0;
			GEnum11 gEnum;
			lock (waveOutLock)
			{
				gEnum = Class18.waveOutReset(hWaveOut);
			}
			if (gEnum != 0)
			{
				throw new GException0(gEnum, "waveOutReset");
			}
			callbackEvent.Set();
		}
	}

	public long GetPosition()
	{
		lock (waveOutLock)
		{
			Struct4 mmTime = default(Struct4);
			mmTime.uint_0 = 4u;
			GException0.smethod_1(Class18.waveOutGetPosition(hWaveOut, out mmTime, Marshal.SizeOf(mmTime)), "waveOutGetPosition");
			if (mmTime.uint_0 != 4)
			{
				throw new Exception($"waveOutGetPosition: wType -> Expected {4}, Received {mmTime.uint_0}");
			}
			return mmTime.uint_3;
		}
	}

	public void Dispose()
	{
		GC.SuppressFinalize(this);
		Dispose(disposing: true);
	}

	protected void Dispose(bool disposing)
	{
		Stop();
		if (disposing)
		{
			DisposeBuffers();
		}
		CloseWaveOut();
	}

	private void CloseWaveOut()
	{
		if (callbackEvent != null)
		{
			callbackEvent.Close();
			callbackEvent = null;
		}
		lock (waveOutLock)
		{
			if (hWaveOut != IntPtr.Zero)
			{
				Class18.waveOutClose(hWaveOut);
				hWaveOut = IntPtr.Zero;
			}
		}
	}

	private void DisposeBuffers()
	{
		if (buffers != null)
		{
			WaveOutBuffer[] array = buffers;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].Dispose();
			}
			buffers = null;
		}
	}

	~WaveOutEvent()
	{
		Dispose(disposing: false);
	}

	private void RaisePlaybackStoppedEvent(Exception e)
	{
		EventHandler<GEventArgs0> handler = this.PlaybackStopped;
		if (handler == null)
		{
			return;
		}
		if (syncContext == null)
		{
			handler(this, new GEventArgs0(e));
			return;
		}
		syncContext.Post(delegate
		{
			handler(this, new GEventArgs0(e));
		}, null);
	}
}
