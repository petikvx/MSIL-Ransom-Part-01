using System;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

internal static class Class28
{
	internal enum Enum10
	{
		const_0,
		const_1,
		const_2,
		const_3
	}

	public const byte byte_0 = 16;

	public const byte byte_1 = 20;

	public const byte byte_2 = 144;

	public const byte byte_3 = 160;

	public const byte byte_4 = 161;

	public const byte byte_5 = 162;

	public const byte byte_6 = 163;

	public const byte byte_7 = 164;

	public const byte byte_8 = 165;

	public const byte byte_9 = 91;

	public const byte byte_10 = 92;

	public const byte byte_11 = 145;

	public const byte byte_12 = 45;

	public const byte byte_13 = 17;

	public const byte byte_14 = 18;

	public const byte byte_15 = 231;

	private static int int_0 = 0;

	private static int int_1 = 0;

	private static byte[] byte_16 = new byte[256];

	private static bool bool_0 = false;

	internal static void smethod_0(int virtualKeyCode, int fuState, out char[] chars)
	{
		IntPtr dwhkl = smethod_4();
		int scanCode = MapVirtualKeyEx(virtualKeyCode, 0, dwhkl);
		smethod_2(virtualKeyCode, scanCode, fuState, dwhkl, out chars);
	}

	internal static void smethod_1(int virtualKeyCode, int scanCode, int fuState, out char[] chars)
	{
		IntPtr dwhkl = smethod_4();
		smethod_2(virtualKeyCode, scanCode, fuState, dwhkl, out chars);
	}

	internal static void smethod_2(int virtualKeyCode, int scanCode, int fuState, IntPtr dwhkl, out char[] chars)
	{
		StringBuilder stringBuilder = new StringBuilder(64);
		Class39 @class = Class39.smethod_0();
		byte[] array = @class.method_0();
		bool flag = false;
		if (@class.method_1((Keys)16))
		{
			array[16] = 128;
		}
		if (@class.method_2((Keys)20))
		{
			array[20] = 1;
		}
		switch (ToUnicodeEx(virtualKeyCode, scanCode, array, stringBuilder, stringBuilder.Capacity, fuState, dwhkl))
		{
		default:
			if (stringBuilder.Length > 1)
			{
				chars = new char[2]
				{
					stringBuilder[0],
					stringBuilder[1]
				};
			}
			else
			{
				chars = new char[1] { stringBuilder[0] };
			}
			break;
		case -1:
			flag = true;
			smethod_3(virtualKeyCode, scanCode, dwhkl);
			chars = null;
			break;
		case 0:
			chars = null;
			break;
		case 1:
			if (stringBuilder.Length > 0)
			{
				chars = new char[1] { stringBuilder[0] };
			}
			else
			{
				chars = null;
			}
			break;
		}
		if (int_0 != 0 && bool_0)
		{
			if (chars != null)
			{
				StringBuilder stringBuilder2 = new StringBuilder(5);
				ToUnicodeEx(int_0, int_1, byte_16, stringBuilder2, stringBuilder2.Capacity, 0, dwhkl);
				bool_0 = false;
				int_0 = 0;
			}
		}
		else
		{
			int_1 = scanCode;
			int_0 = virtualKeyCode;
			bool_0 = flag;
			byte_16 = (byte[])array.Clone();
		}
	}

	private static void smethod_3(int vk, int sc, IntPtr hkl)
	{
		StringBuilder stringBuilder = new StringBuilder(10);
		int num;
		do
		{
			byte[] lpKeyState = new byte[255];
			num = ToUnicodeEx(vk, sc, lpKeyState, stringBuilder, stringBuilder.Capacity, 0, hkl);
		}
		while (num < 0);
	}

	private static IntPtr smethod_4()
	{
		int processId;
		return GetKeyboardLayout(Class31.GetWindowThreadProcessId(Class31.GetForegroundWindow(), out processId));
	}

	[DllImport("user32.dll")]
	[Obsolete("Use ToUnicodeEx instead")]
	public static extern int ToAscii(int uVirtKey, int uScanCode, byte[] lpbKeyState, byte[] lpwTransKey, int fuState);

	[DllImport("user32.dll")]
	public static extern int ToUnicodeEx(int wVirtKey, int wScanCode, byte[] lpKeyState, [Out][MarshalAs(UnmanagedType.LPWStr)] StringBuilder pwszBuff, int cchBuff, int wFlags, IntPtr dwhkl);

	[DllImport("user32.dll")]
	public static extern int GetKeyboardState(byte[] pbKeyState);

	[DllImport("user32.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Auto)]
	public static extern short GetKeyState(int vKey);

	[DllImport("user32.dll", CharSet = CharSet.Auto)]
	internal static extern int MapVirtualKeyEx(int uCode, int uMapType, IntPtr dwhkl);

	[DllImport("user32.dll", CharSet = CharSet.Auto)]
	internal static extern IntPtr GetKeyboardLayout(int dwLayout);
}
